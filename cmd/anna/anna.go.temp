package anna

import (
	"bytes"
	"html/template"
	"os"
	"sort"
	"strings"

	"github.com/acmpesuecc/anna/pkg/helpers"
	"github.com/acmpesuecc/anna/pkg/parser"
)

// This struct holds the data required to render posts.html
type postsTemplateData struct {
	Posts []parser.TemplateData
	parser.TemplateData
}

func (g *Generator) RenderSite(addr string) {
	// Creating the "rendered" directory if not present
	err := os.RemoveAll(SiteDataPath + "rendered/")
	if err != nil {
		g.ErrorLogger.Fatal(err)
	}

	err = os.MkdirAll(SiteDataPath+"rendered/", 0750)
	if err != nil {
		g.ErrorLogger.Fatal(err)
	}

	g.Posts = []parser.TemplateData{}
	g.Templates = make(map[template.URL]parser.TemplateData)
	g.TagsMap = make(map[string][]parser.TemplateData)
	g.parseConfig()
	g.readMdDir(SiteDataPath + "content/")
	g.parseRobots()
	g.generateSitemap()
	g.generateFeed()

	sort.Slice(g.Posts, func(i, j int) bool {
		return g.Posts[i].Frontmatter.Date > g.Posts[j].Frontmatter.Date
	})

	helper := helpers.Helper{
		ErrorLogger:  g.ErrorLogger,
		SiteDataPath: SiteDataPath,
	}

	// Copies the contents of the 'static/' directory to 'rendered/'
	helper.CopyDirectoryContents(SiteDataPath+"static/", SiteDataPath+"rendered/static/")

	templ := helper.ParseLayoutFiles()

	for pagePath, templateData := range g.Templates {
		g.RenderPage(pagePath, templateData, templ, "page")
	}

	var postsBuffer bytes.Buffer

	postsData := postsTemplateData{
		Posts: g.Posts,
		TemplateData: parser.TemplateData{
			Frontmatter: parser.Frontmatter{Title: "Posts"},
			Layout:      g.LayoutConfig,
		},
	}

	err = templ.ExecuteTemplate(&postsBuffer, "posts", postsData)
	if err != nil {
		g.ErrorLogger.Fatal(err)
	}

	// Flushing 'posts.html' to the disk
	err = os.WriteFile(SiteDataPath+"rendered/posts.html", postsBuffer.Bytes(), 0666)
	if err != nil {
		g.ErrorLogger.Fatal(err)
	}

	g.RenderTags(templ)
}

func (g *Generator) RenderPage(pagePath template.URL, templateData parser.TemplateData, templ *template.Template, templateStart string) {
	// Creating subdirectories if the filepath contains '/'
	if strings.Contains(string(pagePath), "/") {
		// Extracting the directory path from the filepath
		dirPath, _ := strings.CutSuffix(string(pagePath), templateData.Filename+".md")
		dirPath = SiteDataPath + "rendered/" + dirPath

		err := os.MkdirAll(dirPath, 0750)
		if err != nil {
			g.ErrorLogger.Fatal(err)
		}
	}

	filename, _ := strings.CutSuffix(string(pagePath), ".md")
	filepath := SiteDataPath + "rendered/" + filename + ".html"
	var buffer bytes.Buffer

	// Storing the rendered HTML file to a buffer
	err := templ.ExecuteTemplate(&buffer, templateStart, templateData)
	if err != nil {
		g.ErrorLogger.Fatal(err)
	}

	// Flushing data from the buffer to the disk
	err = os.WriteFile(filepath, buffer.Bytes(), 0666)
	if err != nil {
		g.ErrorLogger.Fatal(err)
	}
}

func (g *parser.Parser) RenderTags(templ *template.Template) {
	var tagsBuffer bytes.Buffer

	// Extracting tag titles
	tags := make([]string, 0, len(g.TagsMap))
	for tag := range g.TagsMap {
		tags = append(tags, tag)
	}

	tagNames := TemplateData{
		Filename:    "Tags",
		Layout:      g.LayoutConfig,
		Frontmatter: Frontmatter{Title: "Tags"},
		Tags:        tags,
	}

	// Rendering the page displaying all tags
	err := templ.ExecuteTemplate(&tagsBuffer, "all-tags", tagNames)
	if err != nil {
		g.ErrorLogger.Fatal(err)
	}

	// Flushing 'tags.html' to the disk
	err = os.WriteFile(SiteDataPath+"rendered/tags.html", tagsBuffer.Bytes(), 0666)
	if err != nil {
		g.ErrorLogger.Fatal(err)
	}

	// Rendering the subpages with merged tagged posts
	for tag, taggedTemplates := range g.TagsMap {
		pagePath := "tags/" + tag
		templateData := TemplateData{
			Filename: tag,
			Layout:   g.LayoutConfig,
			Frontmatter: Frontmatter{
				Title: tag,
			},
			MergedTags: taggedTemplates,
		}

		g.RenderPage(template.URL(pagePath), templateData, templ, "tag-subpage")
	}
}
